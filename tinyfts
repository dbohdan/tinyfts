#! /usr/bin/env tclsh
# tinyfts: a very small self-contained full text search HTTP server.
# ==============================================================================
# Copyright (c) 2019 D. Bohdan and contributors listed in AUTHORS
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# ==============================================================================

package require Tcl 8.6
package require fileutil 1
package require sqlite3 3.9


### Configuration

# The CSS stylesheet is loaded from a file in [start].
set state(css) {}
set state(hidden-flags) {db-file tcl-file}

set config {
    db-file {}
    tcl-file {}

    css-file vendor/awsm.css/awsm.css

    header {
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>%html([config title])</title>
            <link rel="stylesheet" type="text/css" href="/css">
        </head>
        <body>
    }

    footer {
        </body>
        </html>
    }

    title {
        tinyfts
    }

    subtitle {
        Full text search
    }

    table tinyfts

    min-length 2

    limit 100
}


proc config args {
    return [dict get $::config {*}$args]
}


### Views

namespace eval view {
    namespace import ::config
}


proc view::default {} {
    wapp-trim [config header]
    wapp-trim {
        <header>
            <h1>%html([config title])</h1>
            <p>%html([config subtitle])</p>
        </header>
        <main>
            <form action="/search">
                <input type="text" name="query">
                <input type="submit" value="Search">
            </form>
        </main>
    }
    wapp-trim [config footer]
}


namespace eval view::error {
    namespace path [namespace parent]
}


proc view::error::html {code message} {
    wapp-reply-code $code

    wapp-trim [config header]
    wapp-trim {<header><h1>Error</h1><p>%html($message)</p></header>}
    wapp-trim [config footer]
}


proc view::error::json {code message} {
    wapp-mimetype application/json
    wapp-reply-code $code

    wapp-trim {{"error": "%string($message)"}}
}


proc view::error::tcl {code message} {
    wapp-mimetype text/plain
    wapp-reply-code $code

    wapp-trim [list error $message]
}


namespace eval view::results {
    namespace path [namespace parent]
}


proc view::results::extract-marked {startMarker endMarker text} {
    set re (.*?)${startMarker}(.*?)${endMarker}(.)

    set all {}

    set start 0
    while {[regexp -start $start \
                   -indices \
                   $re \
                   $text \
                   _ \
                   before marked]} {
        lappend all [string range $text {*}$before] \
                    [string range $text {*}$marked]

        set start [expr {[lindex $marked 1] + [string length $endMarker] + 1}]
    }

    set remainer [string range $text $start end]
    if {$remainer ne {}} {
        lappend all $remainer {}
    }

    return $all
}


proc view::results::html {query startMatch endMatch results} {
    wapp-trim [config header]
    wapp-trim {
        <header>
            <h1>Results for "%html($query)"</h1>
        </header>
        <main>
            <ol>
    }

    set n 0
    foreach result $results {
        set dateTime [clock format [dict get $result modified] \
                                   -format {%Y-%m-%d} \
                                   -timezone :Etc/UTC]
        wapp-trim {
            <li>
                <dl>
                    <dt>
                        <a href="%html([dict get $result url])">
                            %html([dict get $result title])</a>
                        (modified %html($dateTime))
                    </dt>
                </dl>
                <dd>
        }

        set marked [extract-marked $startMatch \
                                   $endMatch \
                                   [dict get $result snippet]]
        foreach {before marked} $marked {
            wapp-trim {
                %html($before)<strong>%html($marked)</strong>
            }

            incr n
        }

        wapp-trim </dd>\n</li>
    }

    wapp-trim </ol>
    if {$n == 0} {
        wapp-trim {No results.}
    }
    wapp-trim </main>

    wapp-trim [config footer]
}


proc view::results::json {query startMatch endMatch results} {
    wapp-mimetype application/json

    wapp "\{\"results\": \["
    for {set i 0} {$i < [llength $results]} {incr i} {
        array set r [lindex $results $i]

        set marked [extract-marked $startMatch $endMatch $r(snippet)]
        set snippetParts [lmap x $marked {
            lindex \"[string2json $x]\"
        }]

        wapp-trim {{
            "url": "%unsafe%([string2json $r(url)])%",
            "title": "%unsafe%([string2json $r(title)])%",
            "modified": %unsafe%([string2json $r(modified)])%,
            "snippet": \[%unsafe%([join $snippetParts {, }])%\]
        }}

        if {$i < [llength $results] - 1} {
            wapp ,
        }
    }
    wapp \]\}
}


proc view::results::string2json s {
    return [string map {
        \x00 \\u0000
        \x01 \\u0001
        \x02 \\u0002
        \x03 \\u0003
        \x04 \\u0004
        \x05 \\u0005
        \x06 \\u0006
        \x07 \\u0007
        \x08 \\b
        \x09 \\t
        \x0a \\n
        \x0b \\u000b
        \x0c \\f
        \x0d \\r
        \x0e \\u000e
        \x0f \\u000f
        \x10 \\u0010
        \x11 \\u0011
        \x12 \\u0012
        \x13 \\u0013
        \x14 \\u0014
        \x15 \\u0015
        \x16 \\u0016
        \x17 \\u0017
        \x18 \\u0018
        \x19 \\u0019
        \x1a \\u001a
        \x1b \\u001b
        \x1c \\u001c
        \x1d \\u001d
        \x1e \\u001e
        \x1f \\u001f
        \" \\\"
        \\ \\\\
        </  <\\/
    } [encoding convertto utf-8 $s]]
}


proc view::results::tcl {query startMatch endMatch results} {
    wapp-mimetype text/plain

    wapp "results \{"
    foreach result $results {
        wapp \{\n

        foreach key {url title modified} {
            wapp "    $key [list [dict get $result $key]]\n"
        }

        set marked [extract-marked $startMatch \
                                   $endMatch \
                                   [dict get $result snippet]]
        wapp "    [list snippet $marked]"

        wapp "\n\} "
    }
    wapp \}\n
}


### Controllers

proc fts-query {startMatch endMatch query} {
    return [format {
        SELECT
            url,
            title,
            modified,
            snippet("%1$s", 3, :startMatch, :endMatch, '...', 20) AS snippet
        FROM "%1$s"(:query)
        ORDER BY rank ASC
        LIMIT %2$u
    } [config table] [config limit]]
}


proc wapp-default {} {
    view::default
}


proc wapp-page-css {} {
    wapp-mimetype text/css
    wapp $::css
}


proc wapp-page-search {} {
    wapp-allow-xorigin-params

    set startMatch %%%START_MATCH%%%
    set endMatch %%%END_MATCH%%%

    set query [wapp-param query {}]
    set format [wapp-param format html]
    if {$format ni {html json tcl}} {
        view::error::html 400 {Unknown format.}
        return
    }
    if {[string length [string trim $query]] < [config min-length]} {
        view::error::$format 400 "Query must be at least [config min-length]\
                                  characters long."
        return
    }

    set results {}
    try {
        db eval [fts-query $startMatch $endMatch $query] values {
            lappend results [array get values]
        }
    } on error {msg _} {
        view::error::$format 400 $msg
        return
    }

    view::results::$format $query $startMatch $endMatch $results
}


### CLI


namespace eval cli {
    namespace import ::config
}


proc cli::load-tcl-file {path db} {
    $db eval [format {
        CREATE VIRTUAL TABLE "%1$s" USING fts5(url, title, modified, content);
    } [config table]]

    set dictList [fileutil::cat $path]

    set insertStatement [format {
        INSERT INTO "%1$s"
        VALUES(:url, :title, :modified, :content);
    } [config table]]

    $db transaction {
        foreach dict $dictList {
            foreach key {url title modified content} {
                set $key [dict get $dict $key]
            }

            $db eval $insertStatement
        }
    }
}


proc cli::usage me {
    set options {}
    dict for {k v} $::config {
        if {$k in $::state(hidden-flags)} continue
        set line "\[--$k value\]"

        lappend options $line
    }

    puts stderr "usage: $me (--db-file path|--tcl-file path)\
                 [join $options { }] \[wapp-arg ...\]"
}


proc cli::start {argv0 argv} {
    if {$argv in {/? -? -h -help --help}} {
        usage $argv0
        exit 0
    }

    try {
        cd [file dirname [info script]]
        uplevel 1 {source vendor/wapp/wapp.tcl}

        set wappArgs {}
        foreach {flag v} $argv {
            regsub ^--? $flag {} k

            if {[dict exists $::config $k]} {
                dict set ::config $k $v
            } else {
                lappend wappArgs $flag $v
            }
        }

        if {([config db-file] eq {} && [config tcl-file] eq {})
            || ([config db-file] ne {} && [config tcl-file] ne {})} {
            usage $argv0
            exit 1
        }

        if {[config db-file] ne {}} {
            sqlite3 db [config db-file] -create false -readonly true
        } else {
            sqlite3 db :memory:
            load-tcl-file [config tcl-file] db
        }

        set ::css [fileutil::cat [config css-file]]

        wapp-start $wappArgs
    } on error {msg opts} {
        puts stderr "startup error: [dict get $opts -errorinfo]"
        usage $argv0
        exit 1
    }
}


# If this is the main script...
if {[info exists argv0] && ([file tail [info script]] eq [file tail $argv0])} {
    cli::start $argv0 $argv
}
