#! /usr/bin/env tclsh
# tinyfts: a very small self-contained full text search HTTP server.
# ==============================================================================
# Copyright (c) 2019 D. Bohdan and contributors listed in AUTHORS
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# ==============================================================================

package require Tcl 8.6
package require sqlite3 3.9


### Configuration and globals

# The CSS stylesheet is loaded from a file in [start].
set state {
    css {}
    hidden-flags db-file
    rate {}
}

set config {
    db-file {}

    css-file vendor/tacit/tacit-css.min.css

    header {
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            <title>%html([config::get title])</title>
            <link rel="stylesheet" type="text/css" href="/css">
        </head>
        <body>
    }

    footer {
        </body>
        </html>
    }

    title {
        tinyfts
    }

    subtitle {
        Full text search
    }

    table tinyfts

    min-length 2

    rate-limit 60

    result-limit 100

    log {
        access
        bad-request
        error
        rate
    }
}


proc accessor {name varName} {
    namespace eval $name [format {
        proc get args {
            return [dict get $%1$s {*}$args]
        }


        proc get-default {default args} {
            if {[dict exists $%1$s {*}$args]} {
                return [dict get $%1$s {*}$args]
            } else {
                return $default
            }
        }


        proc set args {
            dict set %1$s {*}$args
        }


        proc update args {
            ::set updateScript [lindex $args end]
            ::set args [lrange $args 0 end-1]
            ::set updated [uplevel 1 [list {*}$updateScript \
                                           [dict get $%1$s {*}$args]]]
            dict set %1$s {*}$args $updated
        }
    } [list $varName]]
}


accessor config ::config
accessor state ::state


proc log {type {message {}}} {
    if {$type ni [config::get log]} return

    set timestamp [clock format [clock seconds] \
                                -format %Y-%m-%dT%H:%M:%SZ \
                                -timezone :Etc/UTC \
    ]

    puts \{[list \
        timestamp $timestamp \
        type $type \
        REMOTE_ADDR [wapp-param REMOTE_ADDR] \
        HTTP_USER_AGENT [wapp-param HTTP_USER_AGENT] \
        url [join [list [wapp-param SELF_URL] [wapp-param PATH_TAIL]] /] \
        QUERY_STRING [wapp-param QUERY_STRING] \
        caller [dict get [info frame -1] proc] \
        message $message \
    ]\}
}


### Views

namespace eval view {
    namespace import ::config
}


proc view::form query {
    wapp-trim {
        <form action="/search">
            <input type="text" name="query" value="%html($query)">
            <input type="submit" value="Search">
        </form>
    }
}


proc view::default {} {
    wapp-trim [config::get header]
    wapp-trim {
        <header>
            <h1>%html([config::get title])</h1>
            <p>%html([config::get subtitle])</p>
        </header>
        <main>
    }
    form {}
    wapp </main>
    wapp-trim [config::get footer]
}


namespace eval view::error {
    namespace path [namespace parent]
}


proc view::error::html {code message} {
    wapp-reply-code $code

    wapp-trim [config::get header]
    wapp-trim {<header><h1>Error</h1><p>%html($message)</p></header>}
    wapp-trim [config::get footer]
}


proc view::error::json {code message} {
    wapp-mimetype application/json
    wapp-reply-code $code

    wapp-trim {{"error": "%string($message)"}}
}


proc view::error::tcl {code message} {
    wapp-mimetype text/plain
    wapp-reply-code $code

    wapp-trim [list error $message]
}


namespace eval view::results {
    namespace path [namespace parent]
}


proc view::results::extract-marked {startMarker endMarker text} {
    set re (.*?)${startMarker}(.*?)${endMarker}(.)

    set all {}

    set start 0
    while {[regexp -start $start \
                   -indices \
                   $re \
                   $text \
                   _ \
                   before marked]} {
        lappend all [string range $text {*}$before] \
                    [string range $text {*}$marked]

        set start [expr {[lindex $marked 1] + [string length $endMarker] + 1}]
    }

    set remainer [string range $text $start end]
    if {$remainer ne {}} {
        lappend all $remainer {}
    }

    return $all
}


proc view::results::html {query startMatch endMatch results} {
    wapp-trim [config::get header]
    wapp \n<main>
    form $query
    wapp \n<ol>\n

    set n 0
    foreach result $results {
        set dateTime [clock format [dict get $result modified] \
                                   -format {%Y-%m-%d} \
                                   -timezone :Etc/UTC]
        wapp-trim {
            <li>
                <dl>
                    <dt>
                        <a href="%html([dict get $result url])">
                            %html([dict get $result title])</a>
                        (modified %html($dateTime))
                    </dt>
                </dl>
                <dd>
        }

        set marked [extract-marked $startMatch \
                                   $endMatch \
                                   [dict get $result snippet]]
        foreach {before marked} $marked {
            wapp-trim {
                %html($before)<strong>%html($marked)</strong>
            }

            incr n
        }

        wapp-trim </dd>\n</li>
    }

    wapp-trim </ol>
    if {$n == 0} {
        wapp-trim {No results.}
    }
    wapp-trim </main>

    if {[llength $results] == [config::get result-limit]} {
        set next [dict get [lindex $results end] rank]
        wapp-trim {
            <footer>
                <a href="/search?query=%html($query)&start=%html($next)">Next page</a>
            </footer>
        }
    }

    wapp-trim [config::get footer]
}


proc view::results::json {query startMatch endMatch results} {
    wapp-mimetype application/json

    wapp \{\n

    if {[llength $results] == [config::get result-limit]} {
        set next [dict get [lindex $results end] rank]
        wapp-subst {"next": "%string($next)",\n}
    }

    wapp {"results": [}
    for {set i 0} {$i < [llength $results]} {incr i} {
        array set r [lindex $results $i]

        set marked [extract-marked $startMatch $endMatch $r(snippet)]
        set snippetParts [lmap x $marked {
            lindex \"[string-to-json $x]\"
        }]

        wapp-trim {{
            "url": "%unsafe%([string-to-json $r(url)])%",
            "title": "%unsafe%([string-to-json $r(title)])%",
            "modified": %unsafe%([string-to-json $r(modified)])%,
            "snippet": \[%unsafe%([join $snippetParts {, }])%\]
        }}

        if {$i < [llength $results] - 1} {
            wapp ,
        }
    }

    wapp \]\}
}


proc view::results::string-to-json s {
    return [string map {
        \x00 \\u0000
        \x01 \\u0001
        \x02 \\u0002
        \x03 \\u0003
        \x04 \\u0004
        \x05 \\u0005
        \x06 \\u0006
        \x07 \\u0007
        \x08 \\b
        \x09 \\t
        \x0a \\n
        \x0b \\u000b
        \x0c \\f
        \x0d \\r
        \x0e \\u000e
        \x0f \\u000f
        \x10 \\u0010
        \x11 \\u0011
        \x12 \\u0012
        \x13 \\u0013
        \x14 \\u0014
        \x15 \\u0015
        \x16 \\u0016
        \x17 \\u0017
        \x18 \\u0018
        \x19 \\u0019
        \x1a \\u001a
        \x1b \\u001b
        \x1c \\u001c
        \x1d \\u001d
        \x1e \\u001e
        \x1f \\u001f
        \" \\\"
        \\ \\\\
        </  <\\/
    } [encoding convertto utf-8 $s]]
}


proc view::results::tcl {query startMatch endMatch results} {
    wapp-mimetype text/plain

    if {[llength $results] == [config::get result-limit]} {
        set next [dict get [lindex $results end] rank]
        wapp [list next $next]\n
    }

    wapp "results \{"

    set first true
    foreach result $results {
        if {!$first} {
            wapp { }
        }
        wapp \{\n

        foreach key {url title modified} {
            wapp "    $key [list [dict get $result $key]]\n"
        }

        set marked [extract-marked $startMatch \
                                   $endMatch \
                                   [dict get $result snippet]]
        wapp "    [list snippet $marked]"

        wapp \n\}

        set first false
    }

    wapp \}\n
}


### Controllers

proc fts-query {startMatch endMatch query startRank} {
    return [format {
        SELECT
            url,
            title,
            modified,
            snippet("%1$s", 3, :startMatch, :endMatch, '...', 20) AS snippet,
            rank
        FROM "%1$s"(:query)
        WHERE rank > %3$f
        ORDER BY rank ASC
        LIMIT %2$u
    } [config::get table] [config::get result-limit] $startRank]
}


namespace eval rate-limit {}


proc rate-limit::allow? client {
    set m [expr {[clock seconds] / 60}]

    if {[state::get-default -1 rate $client last] != $m} {
        dict set ::state rate $client last $m
        dict set ::state rate $client count 0

        return 1
    }

    state::update rate $client count {apply {x {
        incr x
    }}}

    set diff [expr {
        [state::get rate $client count] - [config::get rate-limit]
    }]
    if {$diff > 0} {
        if {$diff == 1} {
            log rate {temporarily blocked remote address}
        }
        return 0
    }

    return 1
}


proc wapp-default {} {
    log access

    view::default
}


proc wapp-page-css {} {
    wapp-mimetype text/css
    wapp [state::get css]
}


proc wapp-page-search {} {
    wapp-allow-xorigin-params

    if {![rate-limit::allow? [wapp-param REMOTE_ADDR]]} {
        wapp-mimetype text/plain
        wapp-reply-code 403

        wapp {Access denied.}

        return
    }

    log access

    set startMatch %%%START_MATCH%%%
    set endMatch %%%END_MATCH%%%

    set format [wapp-param format html]
    set query [wapp-param query {}]
    set start [wapp-param start -1000000]

    if {$format ni {html json tcl}} {
        set msg {Unknown format.}
        view::error::html 400 $msg
        log bad-request $msg

        return
    }
    if {[string length [string trim $query]] < [config::get min-length]} {
        set msg "Query must be at least [config::get min-length]\
                 characters long."
        view::error::$format 400 $msg
        log bad-request $msg

        return
    }

    set results {}
    try {
        db eval [fts-query $startMatch $endMatch $query $start] values {
            lappend results [array get values]
        }
    } on error {msg _} {
        view::error::$format 400 $msg
        log error $msg

        return
    }

    view::results::$format $query $startMatch $endMatch $results
}


### CLI


namespace eval cli {
    namespace import ::config
}


proc cli::read-file args {
    if {[llength $args] == 0} {
        error "wrong # args: should be \"read-file ?options? path"
    }

    set path [lindex $args end]
    set options [lrange $args 0 end-1]

    set ch [open $path r]
    fconfigure $ch {*}$options
    set data [read $ch]
    close $ch

    return $data
}


proc cli::usage me {
    set options {}
    dict for {k v} $::config {
        if {$k in [state::get hidden-flags]} continue
        set line "\[--$k value\]"

        lappend options $line
    }

    puts stderr "usage: $me --db-file path\
                 [join $options { }] \[wapp-arg ...\]"
}


proc cli::start {argv0 argv} {
    if {$argv in {/? -? -h -help --help}} {
        usage $argv0
        exit 0
    }

    try {
        cd [file dirname [info script]]
        uplevel 1 {source vendor/wapp/wapp.tcl}

        set wappArgs {}
        foreach {flag v} $argv {
            regsub ^--? $flag {} k

            if {[dict exists $::config $k]} {
                dict set ::config $k $v
            } else {
                lappend wappArgs $flag $v
            }
        }

        if {[config::get db-file] eq {}} {
            usage $argv0
            exit 1
        }

        sqlite3 db [config::get db-file] -create false -readonly true
        dict set ::state css [read-file [config::get css-file]]

        wapp-start $wappArgs
    } on error {msg opts} {
        puts stderr "startup error: [dict get $opts -errorinfo]"
        usage $argv0
        exit 1
    }
}


# If this is the main script...
if {[info exists argv0] && ([file tail [info script]] eq [file tail $argv0])} {
    cli::start $argv0 $argv
}
